<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Las Aventuras de los Tres</title>

  <link rel="manifest" href="manifest.json" />
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Kids+Play&display=swap');
    body { font-family: 'Kids Play', cursive; }

    /* Contenedor con perspectiva para efecto libro */
    #book  { perspective: 1400px; }
    #sheet { will-change: transform; transform-style: preserve-3d; }

    /* Animaciones del “pase de página” */
    .turn-out-next  { transform-origin: right center;  animation: turnOutNext 250ms ease forwards; }
    .turn-in-next   { transform-origin: right center;  animation: turnInNext  250ms ease forwards; }
    .turn-out-prev  { transform-origin: left  center;  animation: turnOutPrev 250ms ease forwards; }
    .turn-in-prev   { transform-origin: left  center;  animation: turnInPrev  250ms ease forwards; }
    @keyframes turnOutNext { to   { transform: rotateY(-90deg); } }
    @keyframes turnInNext  { from { transform: rotateY( 90deg); } to { transform: rotateY(0deg); } }
    @keyframes turnOutPrev { to   { transform: rotateY( 90deg); } }
    @keyframes turnInPrev  { from { transform: rotateY(-90deg); } to { transform: rotateY(0deg); } }

    /* Mostrar/ocultar flechas SOLO sobre la imagen */
    #imageWrap { position: relative; }
    .image-controls {
      opacity: 0; visibility: hidden; transition: opacity .2s ease;
    }
    /* En escritorio: al pasar el ratón por encima de la imagen */
    .group:hover .image-controls {
      opacity: 1; visibility: visible;
    }
    /* En móvil: clase que forzamos temporalmente con JS al tocar la imagen */
    .show-controls .image-controls {
      opacity: 1; visibility: visible;
    }
  </style>
</head>
<body class="bg-yellow-50 flex items-center justify-center min-h-screen p-4">
  <div id="book" class="w-full max-w-3xl">
    <div id="sheet" class="bg-white shadow-xl rounded-2xl overflow-hidden">
      
      <!-- Imagen + flechas dentro (no pisan el texto) -->
      <div id="imageWrap" class="group">
        <img id="imagen" class="w-full object-cover" alt="Ilustración de página" loading="lazy" />
        <button id="prev"
                class="image-controls absolute left-3 top-1/2 -translate-y-1/2 p-3 rounded-full bg-green-500 text-white shadow"
                aria-label="Página anterior">◀</button>
        <button id="next"
                class="image-controls absolute right-3 top-1/2 -translate-y-1/2 p-3 rounded-full bg-blue-600 text-white shadow"
                aria-label="Página siguiente">▶</button>
      </div>

      <!-- Texto con margen superior -->
      <div id="texto" class="px-8 py-6 mt-2 text-lg leading-relaxed" tabindex="0"></div>
    </div>
  </div>

  <!-- Gestos táctiles -->
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
  <script>
    // ====== Estado ======
    let paginas = [];
    let idx = 0;                 // Siempre arranca en la página 0 (1 para el usuario)
    let locked = false;          // Bloquea mientras animamos/cargamos
    let pendingIndex = null;     // Último destino solicitado durante el bloqueo

    // ====== Elementos ======
    const sheet     = document.getElementById('sheet');
    const imgEl     = document.getElementById('imagen');
    const textoEl   = document.getElementById('texto');
    const prevBtn   = document.getElementById('prev');
    const nextBtn   = document.getElementById('next');
    const imageWrap = document.getElementById('imageWrap');

    // ====== Utilidades ======
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const setDisabled = (s) => {
      prevBtn.disabled = s || idx === 0;
      nextBtn.disabled = s || idx === paginas.length - 1;
      prevBtn.classList.toggle('opacity-50', prevBtn.disabled);
      nextBtn.classList.toggle('opacity-50', nextBtn.disabled);
    };
    const preloadSrc = (i) => { const p = new Image(); p.src = `images/${i+1}.png`; };

    // Carga imagen y hace swap a mitad de la animación
    async function flipTo(target, dir) {
      if (locked || target === idx) return;

      locked = true;
      setDisabled(true);

      const outClass = dir === 'next' ? 'turn-out-next' : 'turn-out-prev';
      const inClass  = dir === 'next' ? 'turn-in-next'  : 'turn-in-prev';
      const duration = 250; // ms por fase

      // Fase 1: giro de salida
      sheet.classList.remove('turn-in-next','turn-in-prev');
      sheet.classList.add(outClass);

      // Prepara siguiente imagen
      const src = `images/${target+1}.png`;
      const pre = new Image(); pre.src = src;

      try {
        if ('decode' in pre) { await pre.decode(); }
        else { await new Promise((res, rej) => { pre.onload = res; pre.onerror = rej; }); }
      } catch (_) { /* sigue aunque decode falle */ }

      // En mitad del pase (tras la fase de salida), hacemos el swap
      await new Promise(r => setTimeout(r, duration));
      imgEl.src = src;
      textoEl.textContent = paginas[target];
      idx = target;

      // Fase 2: giro de entrada
      sheet.classList.remove(outClass);
      sheet.classList.add(inClass);

      // Fin de animación de entrada
      await new Promise(r => setTimeout(r, duration));
      sheet.classList.remove(inClass);

      // Preload vecinos
      if (idx + 1 < paginas.length) preloadSrc(idx + 1);
      if (idx - 1 >= 0)             preloadSrc(idx - 1);

      locked = false;
      setDisabled(false);

      // Atiende petición pendiente si existe
      if (pendingIndex !== null && pendingIndex !== idx) {
        const nextTarget = pendingIndex; pendingIndex = null;
        flipTo(nextTarget, nextTarget > idx ? 'next' : 'prev');
      }
    }

    function navigate(delta) {
      const target = clamp(idx + delta, 0, paginas.length - 1);
      if (locked) { pendingIndex = target; return; }
      flipTo(target, delta > 0 ? 'next' : 'prev');
    }

    // ====== Arranque (siempre página 1) ======
    fetch('texto/paginas.json')
      .then(r => r.json())
      .then(data => {
        paginas = data;
        imgEl.src = 'images/1.png';          // Inicializa sin animación
        textoEl.textContent = paginas[0];
        idx = 0;
        setDisabled(false);
        if (paginas.length > 1) preloadSrc(1);
      })
      .catch(() => { textoEl.textContent = 'Error al cargar el cuento.'; });

    // Eventos de navegación
    prevBtn.addEventListener('click', () => navigate(-1));
    nextBtn.addEventListener('click', () => navigate(1));
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowRight') navigate(1);
      if (e.key === 'ArrowLeft')  navigate(-1);
    });

    const hammer = new Hammer(document.getElementById('book'));
    hammer.on('swipeleft',  () => navigate(1));
    hammer.on('swiperight', () => navigate(-1));

    // ====== Mostrar flechas en móvil al tocar la imagen ======
    let hideTimer;
    const showControls = (ms = 1500) => {
      imageWrap.classList.add('show-controls');
      clearTimeout(hideTimer);
      hideTimer = setTimeout(() => imageWrap.classList.remove('show-controls'), ms);
    };
    imageWrap.addEventListener('touchstart', () => showControls());
    imageWrap.addEventListener('mousemove',  () => showControls(1200)); // también útil en tablet/ratón
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</body>
</html>